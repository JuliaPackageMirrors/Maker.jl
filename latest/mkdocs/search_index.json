{
    "docs": [
        {
            "location": "/", 
            "text": "Maker.jl\n\n\nMaker\n is a \nJulia\n package to set up tasks and  dependencies in a similar fashion to \nmake\n or \nRake\n. Like make, \nMaker\n evaluates file and code dependencies to update processing. The focus here is on data analysis, not build automation for code. Key features for data analysis include:\n\n\n\n\nDetection of code changes\n\u2013If part of the code changes, downstream    dependencies are updated during processing.\n\n\nVariable tasks\n\u2013Most make-like tools rely mainly on files for    dependency analysis. In \nMaker\n, Julia variables can also be used   in this role. That allows more fine-grained control of code and dependencies.    \nMaker\n was derived from \nJake.jl\n by Mike Nolta. \nJuke.jl\n is another make-like tool written in Julia. \n\n\n\n\nMost build tools like make use a Makefile or other build-instruction file. In \nMaker\n, a separate build-script can be used, but the API here focuses on use within Julia script files. The API in \nMaker\n is most similar to Ruby's \nRake\n.\n\n\n\n\nDocumentation\n\n\n\n\nExample\n\n\nAPI\n\n\nmake\n\n\nTargets\n\n\nAbstractTarget\n\n\ntask\n\n\nfile\n\n\ndirectory\n\n\nvariable\n\n\nphony\n\n\n\n\n\n\nUtilities\n\n\nTerminology\n\n\nInternals\n\n\n\n\n\n\nDocumentation Index\n\n\n\n\nmake\n\n\nAbstractTarget\n\n\nDirectoryTarget\n\n\nFileTarget\n\n\nGenericTarget\n\n\nPhonyTarget\n\n\nVariableTarget\n\n\ndirectory\n\n\nfile\n\n\nphony\n\n\ntask\n\n\nvariable\n\n\nclean\n\n\nrm\n\n\ntasks", 
            "title": "Maker"
        }, 
        {
            "location": "/#makerjl", 
            "text": "Maker  is a  Julia  package to set up tasks and  dependencies in a similar fashion to  make  or  Rake . Like make,  Maker  evaluates file and code dependencies to update processing. The focus here is on data analysis, not build automation for code. Key features for data analysis include:   Detection of code changes \u2013If part of the code changes, downstream    dependencies are updated during processing.  Variable tasks \u2013Most make-like tools rely mainly on files for    dependency analysis. In  Maker , Julia variables can also be used   in this role. That allows more fine-grained control of code and dependencies.     Maker  was derived from  Jake.jl  by Mike Nolta.  Juke.jl  is another make-like tool written in Julia.    Most build tools like make use a Makefile or other build-instruction file. In  Maker , a separate build-script can be used, but the API here focuses on use within Julia script files. The API in  Maker  is most similar to Ruby's  Rake .", 
            "title": "Maker.jl"
        }, 
        {
            "location": "/#documentation", 
            "text": "Example  API  make  Targets  AbstractTarget  task  file  directory  variable  phony    Utilities  Terminology  Internals", 
            "title": "Documentation"
        }, 
        {
            "location": "/#documentation-index", 
            "text": "make  AbstractTarget  DirectoryTarget  FileTarget  GenericTarget  PhonyTarget  VariableTarget  directory  file  phony  task  variable  clean  rm  tasks", 
            "title": "Documentation Index"
        }, 
        {
            "location": "/introduction/", 
            "text": "Example\n\n\nThe following shows a brief example of how to define file and variable  dependencies for data processing.\n\n\nMaker\n.\nfile\n(\nin1.csv\n)\n    \n# These are the input files.\n\n\nMaker\n.\nfile\n(\nin2.csv\n)\n\n\n\n# Two input files are processed to produce the file x.csv.\n\n\n# \nx.csv\n is the name of the file task and the name of the file\n\n\n# associated with the task. \nin1.csv\n and \nin2.csv\n are the \n\n\n# dependencies for \nx.csv\n. If either of the inputs are \n\n\n# changed (newer timestamp), this task will run.\n\n\nMaker\n.\nfile\n(\nx.csv\n,\n \n[\nin1.csv\n,\n \nin2.csv\n])\n \ndo\n \n    \nx\n \n=\n \nreadcsv\n(\nin1.csv\n)\n \n+\n \nreadcsv\n(\nin2.csv\n)\n\n    \nprintln\n(\nWriting \nx.csv\n.\n)\n\n    \nwritecsv\n(\nx.csv\n,\n \nx\n)\n \n\nend\n\n\n\n# This is a variable task. It creates a global variable\n\n\n# `x` based on the result of this calculation. \n\n\nMaker\n.\nvariable\n(\nx\n,\n \nx.csv\n)\n \ndo\n \n    \nprintln\n(\nReading `x`.\n)\n\n    \nreadcsv\n(\nx.csv\n)\n\n\nend\n\n\n\n# This simple task defines which target to check\n\n\n# when `make()` is run.\n\n\nMaker\n.\ntask\n(\ndefault\n,\n \nx.csv\n)\n\n\n\nmake\n()\n  \n# Run the \ndefault\n task.\n\n\n\n\n\n\nSee \nhere\n for a longer version of this example. In the example above, do-syntax is used. These use anonymous functions to define actions. Normal, generic functions can also be  used.", 
            "title": "Example"
        }, 
        {
            "location": "/introduction/#example", 
            "text": "The following shows a brief example of how to define file and variable  dependencies for data processing.  Maker . file ( in1.csv )      # These are the input files.  Maker . file ( in2.csv )  # Two input files are processed to produce the file x.csv.  #  x.csv  is the name of the file task and the name of the file  # associated with the task.  in1.csv  and  in2.csv  are the   # dependencies for  x.csv . If either of the inputs are   # changed (newer timestamp), this task will run.  Maker . file ( x.csv ,   [ in1.csv ,   in2.csv ])   do  \n     x   =   readcsv ( in1.csv )   +   readcsv ( in2.csv ) \n     println ( Writing  x.csv . ) \n     writecsv ( x.csv ,   x )   end  # This is a variable task. It creates a global variable  # `x` based on the result of this calculation.   Maker . variable ( x ,   x.csv )   do  \n     println ( Reading `x`. ) \n     readcsv ( x.csv )  end  # This simple task defines which target to check  # when `make()` is run.  Maker . task ( default ,   x.csv )  make ()    # Run the  default  task.   See  here  for a longer version of this example. In the example above, do-syntax is used. These use anonymous functions to define actions. Normal, generic functions can also be  used.", 
            "title": "Example"
        }, 
        {
            "location": "/api/", 
            "text": "API\n\n\nThe main API here is rather basic:\n\n\n\n\n\n\nmake(name=\"default\")\n \u2013 Process the target \nname\n by evaluating dependencies   that need to be updated. \"default\" is the name of the default task. If \nname\n   is a Vector of names, each name is processed sequentially.\n\n\n\n\n\n\nMaker.directory\n, \nMaker.file\n, \nMaker.phony\n, \nMaker.task\n, and   \nMaker.variable\n \u2013 These methods all define tasks or targets to be updated.   Each task has a name, zero or more dependencies, and an action as follows:      \njulia  Maker.task(action::Function, name::AbstractString, dependencies::Vector{AbstractString})\n\n\n\n\n\n\nNormally with the \nfile\n task, the \naction\n will perform an operation to create or update the file of the given name. With the \nvariable\n task, the result of the action is assigned to a variable with the specified name. The \ntask\n target is a generic task that can be used for general processing and to  connect dependencies. All dependencies must be satisfied before running the action.  \nphony\n is like \ntask\n, but the timestamp always appears old, so it doesn't  trigger upstream actions.\n\n\nThe \naction\n function can be called with zero or one arguments. If the one-argument version is available, that version is called. The argument is the \nAbstractTarget\n defined. Here is an example of this use:\n\n\nMaker\n.\nfile\n(\nin.csv\n,\n \nout.csv\n)\n \ndo\n \nt\n\n    \nx\n \n=\n \nreadcsv\n(\nt\n.\ndependencies\n[\n1\n])\n\n    \nwritecsv\n(\nt\n.\nname\n,\n \n3\n \n*\n \nx\n)\n\n\nend\n\n\n\n\n\n\nThe following fields of an AbstractTarget are suitable for access: \nt.name\n, \nt.dependencies\n, \nt.description\n, and \nt.action\n.\n\n\ndirectory\n, \nfile\n, \nphony\n, \ntask\n, and \nvariable\n are all exported, but it is best to fully qualify these to help task definitions stand out.\n\n\nMaker\n works well with \nGlob.jl\n for file and name wildcards.  \nHere\n is an example of how globs can be used currently for traditional make-like  file operations.\n\n\nAlthough the API is geared towards use in scripts, you can use a standalone \"makerfile.jl\" to define tasks. See this \nmakerfile.jl\n for an example. Run with \njulia makerfile.jl cleancov\n, \nbin/maker cleancov\n, or define an alias (using the bash shell in this example):\n\n\nalias\n \nmaker\n=\njulia makerfile.jl\n \nmaker cleancov\n\n\n\n\n\nBy convention, a \"makerfile.jl\" should end with \nmake(ARGS)\n to run make on all arguments.", 
            "title": "API"
        }, 
        {
            "location": "/api/#api", 
            "text": "The main API here is rather basic:    make(name=\"default\")  \u2013 Process the target  name  by evaluating dependencies   that need to be updated. \"default\" is the name of the default task. If  name    is a Vector of names, each name is processed sequentially.    Maker.directory ,  Maker.file ,  Maker.phony ,  Maker.task , and    Maker.variable  \u2013 These methods all define tasks or targets to be updated.   Each task has a name, zero or more dependencies, and an action as follows:       julia  Maker.task(action::Function, name::AbstractString, dependencies::Vector{AbstractString})    Normally with the  file  task, the  action  will perform an operation to create or update the file of the given name. With the  variable  task, the result of the action is assigned to a variable with the specified name. The  task  target is a generic task that can be used for general processing and to  connect dependencies. All dependencies must be satisfied before running the action.   phony  is like  task , but the timestamp always appears old, so it doesn't  trigger upstream actions.  The  action  function can be called with zero or one arguments. If the one-argument version is available, that version is called. The argument is the  AbstractTarget  defined. Here is an example of this use:  Maker . file ( in.csv ,   out.csv )   do   t \n     x   =   readcsv ( t . dependencies [ 1 ]) \n     writecsv ( t . name ,   3   *   x )  end   The following fields of an AbstractTarget are suitable for access:  t.name ,  t.dependencies ,  t.description , and  t.action .  directory ,  file ,  phony ,  task , and  variable  are all exported, but it is best to fully qualify these to help task definitions stand out.  Maker  works well with  Glob.jl  for file and name wildcards.   Here  is an example of how globs can be used currently for traditional make-like  file operations.  Although the API is geared towards use in scripts, you can use a standalone \"makerfile.jl\" to define tasks. See this  makerfile.jl  for an example. Run with  julia makerfile.jl cleancov ,  bin/maker cleancov , or define an alias (using the bash shell in this example):  alias   maker = julia makerfile.jl  \nmaker cleancov  By convention, a \"makerfile.jl\" should end with  make(ARGS)  to run make on all arguments.", 
            "title": "API"
        }, 
        {
            "location": "/make/", 
            "text": "make\n\n\n#\nMaker.make\n \n \nFunction\n.\n\n\n\n\nmake\n(\nname\n::\nAbstractString\n \n=\n \ndefault\n;\n \n     \ndryrun\n::\nBool\n \n=\n \nfalse\n,\n \nverbose\n::\nBool\n \n=\n \nfalse\n)\n\n\nmake\n(\nnames\n::\nAbstractVector\n;\n \n     \ndryrun\n::\nBool\n \n=\n \nfalse\n,\n \nverbose\n::\nBool\n \n=\n \nfalse\n)\n\n\n\n\n\n\nCheck, and if needed, update target \nname\n after updating its dependencies. For multiple targets specified in \nnames\n, run \nmake\n on each item sequentially.\n\n\nIf keyword argument \nverbose\n is set, the chain of targets and dependencies is shown.\n\n\nIf keyword argument \ndryrun\n is set, the chain of targets and actions is shown but not run.", 
            "title": "make"
        }, 
        {
            "location": "/make/#make", 
            "text": "# Maker.make     Function .   make ( name :: AbstractString   =   default ;  \n      dryrun :: Bool   =   false ,   verbose :: Bool   =   false )  make ( names :: AbstractVector ;  \n      dryrun :: Bool   =   false ,   verbose :: Bool   =   false )   Check, and if needed, update target  name  after updating its dependencies. For multiple targets specified in  names , run  make  on each item sequentially.  If keyword argument  verbose  is set, the chain of targets and dependencies is shown.  If keyword argument  dryrun  is set, the chain of targets and actions is shown but not run.", 
            "title": "make"
        }, 
        {
            "location": "/targets/", 
            "text": "Targets\n\n\n\n\nAbstractTarget\n\n\n#\nMaker.AbstractTarget\n \n \nType\n.\n\n\n\n\nMaker.AbstractTarget\n\n\nAbstractTarget\n is an abstract type covering various \"targets\" or \"tasks\". Each of these targets normally has an action and zero or more dependencies.\n\n\n\n\ntask\n\n\n#\nMaker.GenericTarget\n \n \nType\n.\n\n\n\n\nMaker.GenericTarget\n\n\nThe type created by \ntask()\n. Fields expected to be accessed publicly include:\n\n\n\n\nname::UTF8String\n\n\ndependencies::Vector{UTF8String}\n\n\ndescription::UTF8String\n\n\n\n\n#\nMaker.task\n \n \nFunction\n.\n\n\n\n\ntask\n(\naction\n::\nFunction\n,\n \nname\n::\nAbstractString\n,\n \ndependencies\n=\n[])\n\n\ntask\n(\nname\n::\nAbstractString\n,\n \ndependencies\n=\n[])\n \n\n\n\n\n\nDefine and register a \ntask\n target for Maker.jl.\n\n\n\n\n\n\naction\n is the function that operates when the target is   executed. \n\n\n\n\n\n\nname\n refers to the name of the task. \n\n\n\n\n\n\ndependencies\n refers to the name (\nAbstractString\n) or names    (\nVector{AbstractString}\n) of targets that need to be satisfied   for this target before running the \naction\n. These are also referred   to as prerequisites.\n\n\n\n\n\n\nTargets are registered globally.\n\n\ntask\n targets are generic targets used to define actions and dependencies. If a task does not have dependencies, it always runs. If a task has dependencies, the task will run if any of the dependencies has a timestamp newer than the last run of the task. If a file target depends on a task target without dependencies, it will always update.\n\n\nIf the \naction\n or \ndependencies\n of a target are redefined, the target will be marked as stale, and the action will be updated at the next target check.  \n\n\nSee also \nmake\n, \nfile\n, and \nvariable\n. \ntask\n registers a \nGenericTarget\n type.\n\n\n\n\nfile\n\n\n#\nMaker.FileTarget\n \n \nType\n.\n\n\n\n\nMaker.FileTarget\n\n\nThe type created by \nfile()\n. Fields expected to be accessed publicly include:\n\n\n\n\nname::UTF8String\n\n\ndependencies::Vector{UTF8String}\n\n\ndescription::UTF8String\n\n\n\n\n#\nMaker.file\n \n \nFunction\n.\n\n\n\n\nfile\n(\naction\n::\nFunction\n,\n \nname\n::\nAbstractString\n,\n \ndependencies\n=\n[])\n\n\nfile\n(\nname\n::\nAbstractString\n,\n \ndependencies\n=\n[])\n\n\n\n\n\n\nDefine and register a \nfile\n target for Maker.jl.\n\n\n\n\n\n\naction\n is the function that operates when the target is   executed. \n\n\n\n\n\n\nname\n refers to the name of the task or target. \n\n\n\n\n\n\ndependencies\n refers to the name (\nAbstractString\n) or names    (\nVector{AbstractString}\n) of targets that need to be satisfied   for this target. \n\n\n\n\n\n\nTargets are registered globally.\n\n\nfile\n targets use the name of the file as the name of the target. File targets use timestamps to determine when targets need to be updated. File paths are relative to the current working directory.\n\n\nIf the \naction\n or \ndependencies\n of a target are redefined, the target will be marked as stale, and the action will be updated at the next target check.  \n\n\nSee also \nmake\n, \ndirectory\n,, \ntask\n, and \nvariable\n. \nfile\n  registers a \nFileTarget\n type.\n\n\n\n\ndirectory\n\n\n#\nMaker.DirectoryTarget\n \n \nType\n.\n\n\n\n\nMaker.DirectoryTarget\n\n\nThe type created by \ndirectory()\n. Fields expected to be accessed publicly include:\n\n\n\n\nname::UTF8String\n\n\ndependencies::Vector{UTF8String}\n\n\ndescription::UTF8String\n\n\n\n\n#\nMaker.directory\n \n \nFunction\n.\n\n\n\n\ndirectory\n(\nname\n::\nAbstractString\n,\n \ndependencies\n=\n[])\n\n\n\n\n\n\nDefine and register targets for Maker.jl.\n\n\n\n\n\n\nname\n refers to the name of the task or target. \n\n\n\n\n\n\ndependencies\n refers to the name (\nAbstractString\n) or names    (\nVector{AbstractString}\n) of targets that need to be satisfied   for this target. \n\n\n\n\n\n\nTargets are registered globally.\n\n\ndirectory\n targets use the name of the path as the name of the target. No action can be specified. The path \nname\n is created with \nmkpath\n if  it doesn't exist. The path is relative to the current working directory.\n\n\ndirectory\n targets only have a builtin action that creates the  directory if it is missing. A timestamp is stored when the directory is created, but the return from \ntimestamp(\"directorytask\")\n returns the oldest time if the directory exists (it doesn't need to be recreated), and it returns the current time if the directory doesn't exist (it needs  to be created). \n\n\nSee also \nmake\n, \nfile\n, and \ntask\n. \ndirectory\n registers a  \nDirectoryTarget\n type.\n\n\n\n\nvariable\n\n\n#\nMaker.VariableTarget\n \n \nType\n.\n\n\n\n\nMaker.VariableTarget\n\n\nThe type created by \nvariable()\n. Fields expected to be accessed publicly include:\n\n\n\n\nname::UTF8String\n\n\ndependencies::Vector{UTF8String}\n\n\ndescription::UTF8String\n\n\n\n\n#\nMaker.variable\n \n \nFunction\n.\n\n\n\n\nvariable\n(\naction\n::\nFunction\n,\n \nname\n::\nAbstractString\n,\n \ndependencies\n)\n\n\n\n\n\n\nDefine and register targets for Maker.jl.\n\n\n\n\n\n\naction\n is the function that operates when the target is   executed. \n\n\n\n\n\n\nname\n refers to the name of the task or target. \n\n\n\n\n\n\ndependencies\n refers to the name (\nAbstractString\n) or names    (\nVector{AbstractString}\n) of targets that need to be satisfied   for this target before running the \naction\n. These are also referred   to as prerequisites.\n\n\n\n\n\n\nTargets are registered globally.\n\n\nvariable\n targets define an action, and the result of the action will be assigned to a global variable (within the Module where the  definition is created) named by the argument \nname\n. A \nvariable\n task keeps a timestamp  when the action runs. If the result of the action has the same hash as the cached version of the hash, the cached timestamp is used. Using the stored timestamp can reduce the number of unnecessary actions run.\n\n\nIf the \naction\n or \ndependencies\n of a target are redefined, the target will be marked as stale, and the action will be updated at the next target check.  \n\n\nSee also \nmake\n, \nfile\n, and \ntask\n. \nvariable\n registers a \nVariableTarget\n type.\n\n\n\n\nphony\n\n\n#\nMaker.PhonyTarget\n \n \nType\n.\n\n\n\n\nMaker.PhonyTarget\n\n\nThe type created by \nphony()\n. Fields expected to be accessed publicly include:\n\n\n\n\nname::UTF8String\n\n\ndependencies::Vector{UTF8String}\n\n\ndescription::UTF8String\n\n\n\n\n#\nMaker.phony\n \n \nFunction\n.\n\n\n\n\nphony\n(\naction\n::\nFunction\n,\n \nname\n::\nAbstractString\n,\n \ndependencies\n=\n[])\n\n\nphony\n(\nname\n::\nAbstractString\n,\n \ndependencies\n=\n[])\n \n\n\n\n\n\nDefine and register a \nphony\n target for Maker.jl.\n\n\n\n\n\n\naction\n is the function that operates when the target is   executed. \n\n\n\n\n\n\nname\n refers to the name of the task. \n\n\n\n\n\n\ndependencies\n refers to the name (\nAbstractString\n) or names    (\nVector{AbstractString}\n) of targets that need to be satisfied   for this target before running the \naction\n. These are also referred   to as prerequisites.\n\n\n\n\n\n\nTargets are registered globally.\n\n\nphony\n targets are generic targets that follow the same rules as a \ntask\n, but \nphony\n always has an \"ancient\" timestamp meaning it won't trigger upstream changes. It does store a timestamp to  determine whether to execute its own  action based on changes to dependencies.\n\n\nIf the \naction\n or \ndependencies\n of a target are redefined, the target will be marked as stale, and the action will be updated at the next target check.  \n\n\nSee also \nmake\n, \nfile\n, \ntask\n, and \nvariable\n. \nphony\n registers a  \nPhonyTarget\n type.", 
            "title": "Targets"
        }, 
        {
            "location": "/targets/#targets", 
            "text": "", 
            "title": "Targets"
        }, 
        {
            "location": "/targets/#abstracttarget", 
            "text": "# Maker.AbstractTarget     Type .   Maker.AbstractTarget  AbstractTarget  is an abstract type covering various \"targets\" or \"tasks\". Each of these targets normally has an action and zero or more dependencies.", 
            "title": "AbstractTarget"
        }, 
        {
            "location": "/targets/#task", 
            "text": "# Maker.GenericTarget     Type .   Maker.GenericTarget  The type created by  task() . Fields expected to be accessed publicly include:   name::UTF8String  dependencies::Vector{UTF8String}  description::UTF8String   # Maker.task     Function .   task ( action :: Function ,   name :: AbstractString ,   dependencies = [])  task ( name :: AbstractString ,   dependencies = [])    Define and register a  task  target for Maker.jl.    action  is the function that operates when the target is   executed.     name  refers to the name of the task.     dependencies  refers to the name ( AbstractString ) or names    ( Vector{AbstractString} ) of targets that need to be satisfied   for this target before running the  action . These are also referred   to as prerequisites.    Targets are registered globally.  task  targets are generic targets used to define actions and dependencies. If a task does not have dependencies, it always runs. If a task has dependencies, the task will run if any of the dependencies has a timestamp newer than the last run of the task. If a file target depends on a task target without dependencies, it will always update.  If the  action  or  dependencies  of a target are redefined, the target will be marked as stale, and the action will be updated at the next target check.    See also  make ,  file , and  variable .  task  registers a  GenericTarget  type.", 
            "title": "task"
        }, 
        {
            "location": "/targets/#file", 
            "text": "# Maker.FileTarget     Type .   Maker.FileTarget  The type created by  file() . Fields expected to be accessed publicly include:   name::UTF8String  dependencies::Vector{UTF8String}  description::UTF8String   # Maker.file     Function .   file ( action :: Function ,   name :: AbstractString ,   dependencies = [])  file ( name :: AbstractString ,   dependencies = [])   Define and register a  file  target for Maker.jl.    action  is the function that operates when the target is   executed.     name  refers to the name of the task or target.     dependencies  refers to the name ( AbstractString ) or names    ( Vector{AbstractString} ) of targets that need to be satisfied   for this target.     Targets are registered globally.  file  targets use the name of the file as the name of the target. File targets use timestamps to determine when targets need to be updated. File paths are relative to the current working directory.  If the  action  or  dependencies  of a target are redefined, the target will be marked as stale, and the action will be updated at the next target check.    See also  make ,  directory ,,  task , and  variable .  file   registers a  FileTarget  type.", 
            "title": "file"
        }, 
        {
            "location": "/targets/#directory", 
            "text": "# Maker.DirectoryTarget     Type .   Maker.DirectoryTarget  The type created by  directory() . Fields expected to be accessed publicly include:   name::UTF8String  dependencies::Vector{UTF8String}  description::UTF8String   # Maker.directory     Function .   directory ( name :: AbstractString ,   dependencies = [])   Define and register targets for Maker.jl.    name  refers to the name of the task or target.     dependencies  refers to the name ( AbstractString ) or names    ( Vector{AbstractString} ) of targets that need to be satisfied   for this target.     Targets are registered globally.  directory  targets use the name of the path as the name of the target. No action can be specified. The path  name  is created with  mkpath  if  it doesn't exist. The path is relative to the current working directory.  directory  targets only have a builtin action that creates the  directory if it is missing. A timestamp is stored when the directory is created, but the return from  timestamp(\"directorytask\")  returns the oldest time if the directory exists (it doesn't need to be recreated), and it returns the current time if the directory doesn't exist (it needs  to be created).   See also  make ,  file , and  task .  directory  registers a   DirectoryTarget  type.", 
            "title": "directory"
        }, 
        {
            "location": "/targets/#variable", 
            "text": "# Maker.VariableTarget     Type .   Maker.VariableTarget  The type created by  variable() . Fields expected to be accessed publicly include:   name::UTF8String  dependencies::Vector{UTF8String}  description::UTF8String   # Maker.variable     Function .   variable ( action :: Function ,   name :: AbstractString ,   dependencies )   Define and register targets for Maker.jl.    action  is the function that operates when the target is   executed.     name  refers to the name of the task or target.     dependencies  refers to the name ( AbstractString ) or names    ( Vector{AbstractString} ) of targets that need to be satisfied   for this target before running the  action . These are also referred   to as prerequisites.    Targets are registered globally.  variable  targets define an action, and the result of the action will be assigned to a global variable (within the Module where the  definition is created) named by the argument  name . A  variable  task keeps a timestamp  when the action runs. If the result of the action has the same hash as the cached version of the hash, the cached timestamp is used. Using the stored timestamp can reduce the number of unnecessary actions run.  If the  action  or  dependencies  of a target are redefined, the target will be marked as stale, and the action will be updated at the next target check.    See also  make ,  file , and  task .  variable  registers a  VariableTarget  type.", 
            "title": "variable"
        }, 
        {
            "location": "/targets/#phony", 
            "text": "# Maker.PhonyTarget     Type .   Maker.PhonyTarget  The type created by  phony() . Fields expected to be accessed publicly include:   name::UTF8String  dependencies::Vector{UTF8String}  description::UTF8String   # Maker.phony     Function .   phony ( action :: Function ,   name :: AbstractString ,   dependencies = [])  phony ( name :: AbstractString ,   dependencies = [])    Define and register a  phony  target for Maker.jl.    action  is the function that operates when the target is   executed.     name  refers to the name of the task.     dependencies  refers to the name ( AbstractString ) or names    ( Vector{AbstractString} ) of targets that need to be satisfied   for this target before running the  action . These are also referred   to as prerequisites.    Targets are registered globally.  phony  targets are generic targets that follow the same rules as a  task , but  phony  always has an \"ancient\" timestamp meaning it won't trigger upstream changes. It does store a timestamp to  determine whether to execute its own  action based on changes to dependencies.  If the  action  or  dependencies  of a target are redefined, the target will be marked as stale, and the action will be updated at the next target check.    See also  make ,  file ,  task , and  variable .  phony  registers a   PhonyTarget  type.", 
            "title": "phony"
        }, 
        {
            "location": "/utilities/", 
            "text": "Utilities\n\n\nA few utilities are provided to help with tasks:\n\n\n#\nMaker.rm\n \n \nFunction\n.\n\n\n\n\nrm\n(\nname\n::\nAbstractString\n)\n\n\n\n\n\n\nEquivalent to \nBase.rm\n, but it doesn't error if file \nname\n is missing.\n\n\n#\nMaker.clean\n \n \nFunction\n.\n\n\n\n\nclean\n(\nname\n::\nAbstractString\n,\n \nfilelist\n)\n\n\nclean\n(\nfilelist\n)\n\n\n\n\n\n\nCreate a task \nname\n (defaults to \"clean\") that will delete files given in \nfilelist\n.\n\n\n#\nMaker.tasks\n \n \nFunction\n.\n\n\n\n\ntasks\n()\n\n\ntasks\n(\nname\n)\n\n\n\n\n\n\nReturn the target \nname\n or return all targets. Can be used to display a target or all registered targets.", 
            "title": "Utilities"
        }, 
        {
            "location": "/utilities/#utilities", 
            "text": "A few utilities are provided to help with tasks:  # Maker.rm     Function .   rm ( name :: AbstractString )   Equivalent to  Base.rm , but it doesn't error if file  name  is missing.  # Maker.clean     Function .   clean ( name :: AbstractString ,   filelist )  clean ( filelist )   Create a task  name  (defaults to \"clean\") that will delete files given in  filelist .  # Maker.tasks     Function .   tasks ()  tasks ( name )   Return the target  name  or return all targets. Can be used to display a target or all registered targets.", 
            "title": "Utilities"
        }, 
        {
            "location": "/terminology/", 
            "text": "Terminology\n\n\n\n\n\n\naction\n \u2013 The method to be executed when a task is run.\n\n\n\n\n\n\ndependency\n \u2013 Tasks may have dependencies. If task \"A\" has dependencies   \"B\" and \"C\", \nmake(\"A\")\n will check \"B\" and \"C\" before executing \"A\".    Dependencies are stored by name, so task \"B\" can be defined after task \"A\".   Circular dependencies are not currently checked.\n\n\n\n\n\n\nprerequisite\n \u2013 Another name for \ndependency\n.\n\n\n\n\n\n\ntarget\n \u2013 Another name for a \ntask\n.\n\n\n\n\n\n\ntask\n \u2013 The basic unit of work. A task is an AbstractTarget. The   following AbstractTargets are provided:        Registration method | AbstractTarget        \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013- | \u2013\u2013\u2013\u2013\u2013\u2013\u2013-     Maker.directory     | DirectoryTarget     Maker.directory     | DirectoryTarget     Maker.file          | FileTarget          Maker.phony         | PhonyTarget         Maker.task          | GenericTarget       Maker.variable      | VariableTarget", 
            "title": "Terminology"
        }, 
        {
            "location": "/terminology/#terminology", 
            "text": "action  \u2013 The method to be executed when a task is run.    dependency  \u2013 Tasks may have dependencies. If task \"A\" has dependencies   \"B\" and \"C\",  make(\"A\")  will check \"B\" and \"C\" before executing \"A\".    Dependencies are stored by name, so task \"B\" can be defined after task \"A\".   Circular dependencies are not currently checked.    prerequisite  \u2013 Another name for  dependency .    target  \u2013 Another name for a  task .    task  \u2013 The basic unit of work. A task is an AbstractTarget. The   following AbstractTargets are provided:        Registration method | AbstractTarget        \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013- | \u2013\u2013\u2013\u2013\u2013\u2013\u2013-     Maker.directory     | DirectoryTarget     Maker.directory     | DirectoryTarget     Maker.file          | FileTarget          Maker.phony         | PhonyTarget         Maker.task          | GenericTarget       Maker.variable      | VariableTarget", 
            "title": "Terminology"
        }, 
        {
            "location": "/internals/", 
            "text": "Internals\n\n\nMaker\n uses the global Dict \nMaker.TARGETS\n to store active tasks. Some state is also stored in a \nJLD\n file \".maker-cache.jld\" in the active directory. This stores hashes for functions and variables along with timestamps. This allows \nMaker\n to be used between sessions. \n\n\nNote that tasks are defined globally, so they may be defined in modules or in the \nMain\n module. \nmake\n works fine in a module for tasks defined in that module. You cannot run all actions in \nMain\n that are defined in another module (particularly for variable tasks).\n\n\nThe hashing for functions and variables is not likely to stay the same between Julia versions. It's also different for 32- and 64-bit versions. It's still up in the air how to deal with this. Also, hashing for v0.4 anonymous functions  has file information removed.\n\n\nTimestamps are stored for all tasks, even file tasks. On some filesystems,  \nmtime\n only has an accuracy of one second, and this can cause inaccuracies  with variable timestamps.\n\n\nNote that parallel operation may be tricky. One may have to be careful using  \n@everywhere\n and friends with \nMaker\n. Each process might try to update  dependencies at the same time, leading to race conditions. Another topic to think about is how to take advantage of parallel operations (or threads when  they come to Julia).", 
            "title": "Internals"
        }, 
        {
            "location": "/internals/#internals", 
            "text": "Maker  uses the global Dict  Maker.TARGETS  to store active tasks. Some state is also stored in a  JLD  file \".maker-cache.jld\" in the active directory. This stores hashes for functions and variables along with timestamps. This allows  Maker  to be used between sessions.   Note that tasks are defined globally, so they may be defined in modules or in the  Main  module.  make  works fine in a module for tasks defined in that module. You cannot run all actions in  Main  that are defined in another module (particularly for variable tasks).  The hashing for functions and variables is not likely to stay the same between Julia versions. It's also different for 32- and 64-bit versions. It's still up in the air how to deal with this. Also, hashing for v0.4 anonymous functions  has file information removed.  Timestamps are stored for all tasks, even file tasks. On some filesystems,   mtime  only has an accuracy of one second, and this can cause inaccuracies  with variable timestamps.  Note that parallel operation may be tricky. One may have to be careful using   @everywhere  and friends with  Maker . Each process might try to update  dependencies at the same time, leading to race conditions. Another topic to think about is how to take advantage of parallel operations (or threads when  they come to Julia).", 
            "title": "Internals"
        }, 
        {
            "location": "/NEWS/", 
            "text": "Maker v0.3.0 Release Notes\n\n\n\n\nDocumentation added\n\n\nSupport for default dependencies\n\n\nAdded a phony target\n\n\n\n\n\n\nMaker v0.2.1 Release Notes\n\n\n\n\nInitial release", 
            "title": "Release notes"
        }, 
        {
            "location": "/NEWS/#maker-v030-release-notes", 
            "text": "Documentation added  Support for default dependencies  Added a phony target", 
            "title": "Maker v0.3.0 Release Notes"
        }, 
        {
            "location": "/NEWS/#maker-v021-release-notes", 
            "text": "Initial release", 
            "title": "Maker v0.2.1 Release Notes"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "The MIT License (MIT) Copyright (c) 2013 Mike Nolta \n and Copyright (c) 2016 Tom Short\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}